{"version":3,"sources":["../../../node_modules/react-hook-form/dist/index.esm.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","../../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js"],"names":["isHTMLElement","value","HTMLElement","EVENTS","VALIDATION_MODE","INPUT_VALIDATION_RULES","attachEventListeners","shouldAttachChangeEvent","handleChange","ref","addEventListener","isNullOrUndefined","isObjectType","isObject","Array","isArray","Date","isKey","test","compact","filter","Boolean","stringToPath","input","replace","split","set","object","path","index","tempPath","length","lastIndex","key","newValue","objValue","isNaN","transformToNestObject","data","isUndefined","val","undefined","get","obj","defaultValue","result","reduce","focusOnErrorField","fields","fieldErrors","field","focus","options","removeAllEventListeners","validateWithStateUpdate","removeEventListener","defaultReturn","isValid","getRadioValue","previous","option","checked","isRadioInput","element","type","isFileInput","isCheckBoxInput","isMultipleSelect","defaultResult","validResult","getCheckboxValue","values","map","attributes","getFieldValue","fieldsRef","name","shallowFieldsStateRef","excludeDisabled","current","disabled","files","selected","isDetached","nodeType","Node","DOCUMENT_NODE","parentNode","isEmptyObject","Object","keys","isBoolean","unset","updatePath","childObject","slice","baseGet","previousObjRef","k","objectRef","currentPaths","currentPathsLength","item","isSameRef","fieldValue","findRemovedFieldAndRemoveListener","shouldUnregister","forceDelete","fieldRef","forEach","setFieldArrayDirtyFields","defaultValues","dirtyFields","parentName","assign","isString","isPrimitive","getFieldsValues","shallowFieldsState","search","output","startsWith","find","deepMerge","target","source","targetValue","sourceValue","_a","deepEqual","object1","object2","isErrorObject","keys1","keys2","includes","val1","val2","isErrorStateChanged","errors","error","validFields","fieldsWithValidation","previousError","isRegex","RegExp","getValueAndMessage","validationData","message","isFunction","isMessage","isValidElement","getValidateError","appendErrors","validateAllFieldCriteria","types","validateField","a","required","maxLength","minLength","min","max","pattern","validate","isRadio","isCheckBox","isRadioOrCheckbox","isEmpty","appendErrorsCurry","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","maxOutput","minOutput","valueNumber","valueAsNumber","parseFloat","exceedMin","valueDate","valueAsDate","maxLengthOutput","minLengthOutput","patternValue","validateRef","validateError","validationResult","entries","validateFunction","validateResult","getPath","pathWithIndex","getInnerPath","flat","Infinity","assignWatchFields","fieldValues","fieldName","watchFields","inputValue","isSingleField","add","skipValidation","isOnBlur","isOnChange","isOnTouch","isTouched","isReValidateOnBlur","isReValidateOnChange","isBlurEvent","isSubmitted","isOnAll","getFieldArrayParentName","substring","indexOf","isMatchFieldArrayName","searchName","isNameInFieldArray","names","some","isSelectInput","onDomRemove","removeFieldEventListenerAndRef","observer","MutationObserver","observe","window","document","childList","subtree","cloneObject","isWeb","copy","File","getTime","Set","Map","modeChecker","mode","isOnSubmit","isRadioOrCheckboxFunction","isWindowUndefined","isProxyEnabled","Proxy","useForm","reValidateMode","resolver","context","shouldFocusError","criteriaMode","useRef","fieldArrayDefaultValuesRef","fieldArrayValuesRef","watchFieldsRef","useWatchFieldsRef","useWatchRenderFunctionsRef","fieldsWithValidationRef","validFieldsRef","defaultValuesRef","defaultValuesAtRenderRef","isUnMount","isWatchAllRef","handleChangeRef","resetFieldArrayFunctionRef","contextRef","resolverRef","fieldArrayNamesRef","modeRef","isValidateAllFieldCriteria","useState","isDirty","submitCount","touched","isSubmitting","isSubmitSuccessful","formState","setFormState","readFormStateRef","formStateRef","observerRef","updateFormState","useCallback","state","shouldRenderBaseOnError","shouldRender","shouldReRender","setFieldValue","rawValue","radioRef","selectRef","checkboxRef","isFormDirty","formValues","getValues","updateAndGetDirtyState","isFieldDirty","isDirtyFieldExist","previousIsDirty","isChanged","executeValidation","skipReRender","executeSchemaOrResolverValidation","previousFormIsValid","isInputsValid","every","trigger","Promise","all","setInternalValues","shouldDirty","shouldValidate","setInternalValue","config","has","isFieldWatched","match","renderWatchedInputs","found","size","setValue","setFieldArrayDefaultValues","payload","shouldSkipValidation","parentNodeName","lastIndexOf","currentError","validateResolver","removeFieldEventListener","updateWatchedValue","clearErrors","inputName","setError","shouldFocus","watchInternal","fieldNames","watchId","combinedDefaultValues","fieldArrayValue","watch","unregister","registerFieldRef","validateOptions","fieldRefAndValidationOptions","isFieldArray","compareRef","currentRef","isEmptyDefaultValue","isEmptyUnmountFields","then","register","refOrValidationOptions","rules","handleSubmit","onValid","onInvalid","e","preventDefault","persist","fieldError","resetRefs","reset","omitResetState","inputRef","closest","resetFieldArray","useEffect","disconnect","commonProps","control","useMemo","prop","__rest","s","t","p","prototype","hasOwnProperty","call","getOwnPropertySymbols","i","propertyIsEnumerable","FormContext","createContext","displayName","useFormContext","useContext","FormProvider","children","props","createElement","Provider","generateId","d","performance","now","c","r","Math","random","toString","useWatch","methods","updateValue","idRef","defaultValueRef","id","watchFieldsHookRender","watchFieldsHook","Controller","as","render","onFocus","rest","isNotFieldArray","getInitialValue","setInputStateValue","valueRef","onFocusRef","commonTask","event","getInputValue","registerField","shouldUpdateValue","defineProperty","onBlur","onChange","cloneElement","_createForOfIteratorHelper","o","Symbol","iterator","F","n","done","_e","f","TypeError","it","err","normalCompletion","didErr","step","next","_e2","_toConsumableArray","arr","arrayLikeToArray","iter","from","unsupportedIterableToArray"],"mappings":"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","file":"static/js/1.77a3a37a.chunk.js","sourcesContent":["import { isValidElement, useRef, useState, useCallback, useEffect, useMemo, createContext, useContext, createElement, cloneElement } from 'react';\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst SELECT = 'select';\r\nconst UNDEFINED = 'undefined';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nfunction attachEventListeners({ ref }, shouldAttachChangeEvent, handleChange) {\r\n    if (isHTMLElement(ref) && handleChange) {\r\n        ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\r\n        ref.addEventListener(EVENTS.BLUR, handleChange);\r\n    }\r\n}\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !(value instanceof Date);\n\nvar isKey = (value) => !Array.isArray(value) &&\r\n    (/^\\w*$/.test(value) ||\r\n        !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n\nvar compact = (value) => value.filter(Boolean);\n\nvar stringToPath = (input) => compact(input\r\n    .replace(/[\"|']/g, '')\r\n    .replace(/\\[/g, '.')\r\n    .replace(/\\]/g, '')\r\n    .split('.'));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar transformToNestObject = (data, value = {}) => {\r\n    for (const key in data) {\r\n        !isKey(key) ? set(value, key, data[key]) : (value[key] = data[key]);\r\n    }\r\n    return value;\r\n};\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\r\n    for (const key in fields) {\r\n        if (get(fieldErrors, key)) {\r\n            const field = fields[key];\r\n            if (field) {\r\n                if (field.ref.focus && isUndefined(field.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (field.options) {\r\n                    field.options[0].ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (isHTMLElement(ref) && ref.removeEventListener) {\r\n        ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n    }\r\n};\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: '',\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.ref.checked\r\n        ? {\r\n            isValid: true,\r\n            value: option.ref.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.ref.checked)\r\n                .map(({ ref: { value } }) => value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        const { checked, value, attributes } = options[0].ref;\r\n        return checked\r\n            ? attributes && !isUndefined(attributes.value)\r\n                ? isUndefined(value) || value === ''\r\n                    ? validResult\r\n                    : { value: value, isValid: true }\r\n                : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nfunction getFieldValue(fieldsRef, name, shallowFieldsStateRef, excludeDisabled) {\r\n    const field = fieldsRef.current[name];\r\n    if (field) {\r\n        const { ref: { value, disabled }, ref, } = field;\r\n        if (disabled && excludeDisabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field.options).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field.options).value;\r\n        }\r\n        return value;\r\n    }\r\n    if (shallowFieldsStateRef) {\r\n        return get(shallowFieldsStateRef.current, name);\r\n    }\r\n}\n\nfunction isDetached(element) {\r\n    if (!element) {\r\n        return true;\r\n    }\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    return isDetached(element.parentNode);\r\n}\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const path = updatePath.slice(0, -1);\r\n    const length = path.length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef = undefined;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef = undefined;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\r\nfunction findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, shallowFieldsStateRef, shouldUnregister, forceDelete) {\r\n    const { ref, ref: { name, type }, } = field;\r\n    const fieldRef = fieldsRef.current[name];\r\n    if (!shouldUnregister) {\r\n        const value = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\r\n        !isUndefined(value) && set(shallowFieldsStateRef.current, name, value);\r\n    }\r\n    if (!type) {\r\n        delete fieldsRef.current[name];\r\n        return;\r\n    }\r\n    if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\r\n        if (Array.isArray(fieldRef.options) && fieldRef.options.length) {\r\n            compact(fieldRef.options).forEach((option, index) => {\r\n                if ((option.ref &&\r\n                    isDetached(option.ref) &&\r\n                    isSameRef(option, option.ref)) ||\r\n                    forceDelete) {\r\n                    removeAllEventListeners(option.ref, handleChange);\r\n                    unset(fieldRef.options, `[${index}]`);\r\n                }\r\n            });\r\n            if (fieldRef.options && !compact(fieldRef.options).length) {\r\n                delete fieldsRef.current[name];\r\n            }\r\n        }\r\n        else {\r\n            delete fieldsRef.current[name];\r\n        }\r\n    }\r\n    else if ((isDetached(ref) && isSameRef(fieldRef, ref)) || forceDelete) {\r\n        removeAllEventListeners(ref, handleChange);\r\n        delete fieldsRef.current[name];\r\n    }\r\n}\n\nfunction setFieldArrayDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setFieldArrayDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                get(defaultValues[index] || {}, key) === values[index][key]\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        !dirtyFields.length &&\r\n            parentNode &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields.length ? dirtyFields : undefined;\r\n}\n\nvar isString = (value) => typeof value === 'string';\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nvar getFieldsValues = (fieldsRef, shallowFieldsState, shouldUnregister, excludeDisabled, search) => {\r\n    const output = {};\r\n    for (const name in fieldsRef.current) {\r\n        if (isUndefined(search) ||\r\n            (isString(search)\r\n                ? name.startsWith(search)\r\n                : Array.isArray(search) && search.find((data) => name.startsWith(data)))) {\r\n            output[name] = getFieldValue(fieldsRef, name, undefined, excludeDisabled);\r\n        }\r\n    }\r\n    return shouldUnregister\r\n        ? transformToNestObject(output)\r\n        : deepMerge(shallowFieldsState, transformToNestObject(output));\r\n};\n\nfunction deepEqual(object1, object2, isErrorObject) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        object1 instanceof Date ||\r\n        object2 instanceof Date) {\r\n        return object1 === object2;\r\n    }\r\n    const keys1 = Object.keys(object1);\r\n    const keys2 = Object.keys(object2);\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    for (const key of keys1) {\r\n        if (!(isErrorObject && ['ref', 'context'].includes(key))) {\r\n            const val1 = object1[key];\r\n            const val2 = object2[key];\r\n            if ((isObject(val1) || Array.isArray(val1)) &&\r\n                (isObject(val2) || Array.isArray(val2))\r\n                ? !deepEqual(val1, val2, isErrorObject)\r\n                : val1 !== val2) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction isErrorStateChanged({ errors, name, error, validFields, fieldsWithValidation, }) {\r\n    const isValid = isUndefined(error);\r\n    const previousError = get(errors, name);\r\n    return ((isValid && !!previousError) ||\r\n        (!isValid && !deepEqual(previousError, error, true)) ||\r\n        (isValid && get(fieldsWithValidation, name) && !get(validFields, name)));\r\n}\n\nvar isRegex = (value) => value instanceof RegExp;\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isMessage = (value) => isString(value) || (isObject(value) && isValidElement(value));\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\r\n    if (validateAllFieldCriteria) {\r\n        const error = errors[name];\r\n        return Object.assign(Object.assign({}, error), { types: Object.assign(Object.assign({}, (error && error.types ? error.types : {})), { [type]: message || true }) });\r\n    }\r\n    return {};\r\n};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, { ref, ref: { type, value }, options, required, maxLength, minLength, min, max, pattern, validate, }, shallowFieldsStateRef) => {\r\n    const name = ref.name;\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = value === '';\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, (exceedMax\r\n            ? appendErrorsCurry(maxType, message)\r\n            : appendErrorsCurry(minType, message)));\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\r\n            (isBoolean(value) && !value) ||\r\n            (isCheckBox && !getCheckboxValue(options).isValid) ||\r\n            (isRadio && !getRadioValue(options).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox\r\n                    ? ((fieldsRef.current[name].options || [])[0] || {}).ref\r\n                    : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (type === 'number' || (!type && !isNaN(value))) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(value);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(value);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && !isEmpty && (maxLength || minLength)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            value.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            value.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\r\n        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(fieldValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nconst getPath = (path, values) => {\r\n    const getInnerPath = (key, value, isObject) => {\r\n        const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\r\n        return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\r\n    };\r\n    return Object.entries(values)\r\n        .map(([key, value]) => getInnerPath(key, value, isObject(values)))\r\n        .flat(Infinity);\r\n};\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\r\n    let value;\r\n    watchFields.add(fieldName);\r\n    if (isEmptyObject(fieldValues)) {\r\n        value = undefined;\r\n    }\r\n    else {\r\n        value = get(fieldValues, fieldName);\r\n        if (isObject(value) || Array.isArray(value)) {\r\n            getPath(fieldName, value).forEach((name) => watchFields.add(name));\r\n        }\r\n    }\r\n    return isUndefined(value)\r\n        ? isSingleField\r\n            ? inputValue\r\n            : get(inputValue, fieldName)\r\n        : value;\r\n};\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar getFieldArrayParentName = (name) => name.substring(0, name.indexOf('['));\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}([|.)\\\\d+`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\r\nvar isNameInFieldArray = (names, name) => [...names].some((current) => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = (element) => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(fieldsRef, removeFieldEventListenerAndRef) {\r\n    const observer = new MutationObserver(() => {\r\n        for (const field of Object.values(fieldsRef.current)) {\r\n            if (field && field.options) {\r\n                for (const option of field.options) {\r\n                    if (option && option.ref && isDetached(option.ref)) {\r\n                        removeFieldEventListenerAndRef(field);\r\n                    }\r\n                }\r\n            }\r\n            else if (field && isDetached(field.ref)) {\r\n                removeFieldEventListenerAndRef(field);\r\n            }\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\nfunction cloneObject(data, isWeb) {\r\n    let copy;\r\n    if (isPrimitive(data) || (isWeb && data instanceof File)) {\r\n        return data;\r\n    }\r\n    if (data instanceof Date) {\r\n        copy = new Date(data.getTime());\r\n        return copy;\r\n    }\r\n    if (data instanceof Set) {\r\n        copy = new Set();\r\n        for (const item of data) {\r\n            copy.add(item);\r\n        }\r\n        return copy;\r\n    }\r\n    if (data instanceof Map) {\r\n        copy = new Map();\r\n        for (const key of data.keys()) {\r\n            copy.set(key, cloneObject(data.get(key), isWeb));\r\n        }\r\n        return copy;\r\n    }\r\n    copy = Array.isArray(data) ? [] : {};\r\n    for (const key in data) {\r\n        copy[key] = cloneObject(data[key], isWeb);\r\n    }\r\n    return copy;\r\n}\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nconst isWindowUndefined = typeof window === UNDEFINED;\r\nconst isWeb = typeof document !== UNDEFINED &&\r\n    !isWindowUndefined &&\r\n    !isUndefined(window.HTMLElement);\r\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, shouldUnregister = true, criteriaMode, } = {}) {\r\n    const fieldsRef = useRef({});\r\n    const fieldArrayDefaultValuesRef = useRef({});\r\n    const fieldArrayValuesRef = useRef({});\r\n    const watchFieldsRef = useRef(new Set());\r\n    const useWatchFieldsRef = useRef({});\r\n    const useWatchRenderFunctionsRef = useRef({});\r\n    const fieldsWithValidationRef = useRef({});\r\n    const validFieldsRef = useRef({});\r\n    const defaultValuesRef = useRef(defaultValues);\r\n    const defaultValuesAtRenderRef = useRef({});\r\n    const isUnMount = useRef(false);\r\n    const isWatchAllRef = useRef(false);\r\n    const handleChangeRef = useRef();\r\n    const shallowFieldsStateRef = useRef({});\r\n    const resetFieldArrayFunctionRef = useRef({});\r\n    const contextRef = useRef(context);\r\n    const resolverRef = useRef(resolver);\r\n    const fieldArrayNamesRef = useRef(new Set());\r\n    const modeRef = useRef(modeChecker(mode));\r\n    const { isOnSubmit, isOnTouch } = modeRef.current;\r\n    const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\r\n    const [formState, setFormState] = useState({\r\n        isDirty: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touched: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: !isOnSubmit,\r\n        errors: {},\r\n    });\r\n    const readFormStateRef = useRef({\r\n        isDirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        touched: !isProxyEnabled || isOnTouch,\r\n        isSubmitting: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n    });\r\n    const formStateRef = useRef(formState);\r\n    const observerRef = useRef();\r\n    const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange, } = useRef(modeChecker(reValidateMode)).current;\r\n    contextRef.current = context;\r\n    resolverRef.current = resolver;\r\n    formStateRef.current = formState;\r\n    shallowFieldsStateRef.current = shouldUnregister\r\n        ? {}\r\n        : isEmptyObject(shallowFieldsStateRef.current)\r\n            ? cloneObject(defaultValues, isWeb)\r\n            : shallowFieldsStateRef.current;\r\n    const updateFormState = useCallback((state = {}) => !isUnMount.current &&\r\n        setFormState(Object.assign(Object.assign({}, formStateRef.current), state)), []);\r\n    const shouldRenderBaseOnError = useCallback((name, error, shouldRender = false, state = {}, isValid) => {\r\n        let shouldReRender = shouldRender ||\r\n            isErrorStateChanged({\r\n                errors: formStateRef.current.errors,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n        const previousError = get(formStateRef.current.errors, name);\r\n        if (error) {\r\n            unset(validFieldsRef.current, name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    !previousError ||\r\n                    !deepEqual(previousError, error, true);\r\n            set(formStateRef.current.errors, name, error);\r\n        }\r\n        else {\r\n            if (get(fieldsWithValidationRef.current, name) || resolverRef.current) {\r\n                set(validFieldsRef.current, name, true);\r\n                shouldReRender = shouldReRender || previousError;\r\n            }\r\n            unset(formStateRef.current.errors, name);\r\n        }\r\n        if ((shouldReRender && !isNullOrUndefined(shouldRender)) ||\r\n            !isEmptyObject(state)) {\r\n            updateFormState(Object.assign(Object.assign(Object.assign({}, state), { errors: formStateRef.current.errors }), (resolverRef.current ? { isValid: !!isValid } : {})));\r\n        }\r\n    }, []);\r\n    const setFieldValue = useCallback((name, rawValue) => {\r\n        const { ref, options } = fieldsRef.current[name];\r\n        const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(ref) && options) {\r\n            options.forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isFileInput(ref) && !isString(value)) {\r\n            ref.files = value;\r\n        }\r\n        else if (isMultipleSelect(ref)) {\r\n            [...ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else if (isCheckBoxInput(ref) && options) {\r\n            options.length > 1\r\n                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = Array.isArray(value)\r\n                    ? !!value.find((data) => data === checkboxRef.value)\r\n                    : value === checkboxRef.value))\r\n                : (options[0].ref.checked = !!value);\r\n        }\r\n        else {\r\n            ref.value = value;\r\n        }\r\n    }, []);\r\n    const isFormDirty = useCallback((name, data) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            const formValues = getValues();\r\n            name && data && set(formValues, name, data);\r\n            return !deepEqual(formValues, isEmptyObject(defaultValuesRef.current)\r\n                ? defaultValuesAtRenderRef.current\r\n                : defaultValuesRef.current);\r\n        }\r\n        return false;\r\n    }, []);\r\n    const updateAndGetDirtyState = useCallback((name, shouldRender = true) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            const isFieldDirty = !deepEqual(get(defaultValuesAtRenderRef.current, name), getFieldValue(fieldsRef, name, shallowFieldsStateRef));\r\n            const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\r\n            const previousIsDirty = formStateRef.current.isDirty;\r\n            isFieldDirty\r\n                ? set(formStateRef.current.dirtyFields, name, true)\r\n                : unset(formStateRef.current.dirtyFields, name);\r\n            const state = {\r\n                isDirty: isFormDirty(),\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            };\r\n            const isChanged = (readFormStateRef.current.isDirty &&\r\n                previousIsDirty !== state.isDirty) ||\r\n                (readFormStateRef.current.dirtyFields &&\r\n                    isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\r\n            if (isChanged && shouldRender) {\r\n                formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), state);\r\n                updateFormState(Object.assign({}, state));\r\n            }\r\n            return isChanged ? state : {};\r\n        }\r\n        return {};\r\n    }, []);\r\n    const executeValidation = useCallback(async (name, skipReRender) => {\r\n        if (fieldsRef.current[name]) {\r\n            const error = (await validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], shallowFieldsStateRef))[name];\r\n            shouldRenderBaseOnError(name, error, skipReRender);\r\n            return isUndefined(error);\r\n        }\r\n        return false;\r\n    }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = useCallback(async (names) => {\r\n        const { errors } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\r\n        const previousFormIsValid = formStateRef.current.isValid;\r\n        if (Array.isArray(names)) {\r\n            const isInputsValid = names\r\n                .map((name) => {\r\n                const error = get(errors, name);\r\n                error\r\n                    ? set(formStateRef.current.errors, name, error)\r\n                    : unset(formStateRef.current.errors, name);\r\n                return !error;\r\n            })\r\n                .every(Boolean);\r\n            updateFormState({\r\n                isValid: isEmptyObject(errors),\r\n                errors: formStateRef.current.errors,\r\n            });\r\n            return isInputsValid;\r\n        }\r\n        else {\r\n            const error = get(errors, names);\r\n            shouldRenderBaseOnError(names, error, previousFormIsValid !== isEmptyObject(errors), {}, isEmptyObject(errors));\r\n            return !error;\r\n        }\r\n    }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\r\n    const trigger = useCallback(async (name) => {\r\n        const fields = name || Object.keys(fieldsRef.current);\r\n        if (resolverRef.current) {\r\n            return executeSchemaOrResolverValidation(fields);\r\n        }\r\n        if (Array.isArray(fields)) {\r\n            !name && (formStateRef.current.errors = {});\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, null)));\r\n            updateFormState();\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields, readFormStateRef.current.isValid);\r\n    }, [executeSchemaOrResolverValidation, executeValidation]);\r\n    const setInternalValues = useCallback((name, value, { shouldDirty, shouldValidate }) => {\r\n        const data = {};\r\n        set(data, name, value);\r\n        for (const fieldName of getPath(name, value)) {\r\n            if (fieldsRef.current[fieldName]) {\r\n                setFieldValue(fieldName, get(data, fieldName));\r\n                shouldDirty && updateAndGetDirtyState(fieldName);\r\n                shouldValidate && trigger(fieldName);\r\n            }\r\n        }\r\n    }, [trigger, setFieldValue, updateAndGetDirtyState]);\r\n    const setInternalValue = useCallback((name, value, config = {}) => {\r\n        if (fieldsRef.current[name]) {\r\n            setFieldValue(name, value);\r\n            config.shouldDirty && updateAndGetDirtyState(name);\r\n        }\r\n        else if (!isPrimitive(value)) {\r\n            setInternalValues(name, value, config);\r\n            if (fieldArrayNamesRef.current.has(name)) {\r\n                fieldArrayDefaultValuesRef.current[name] = value;\r\n                resetFieldArrayFunctionRef.current[name]({\r\n                    [name]: value,\r\n                });\r\n                if ((readFormStateRef.current.isDirty ||\r\n                    readFormStateRef.current.dirtyFields) &&\r\n                    config.shouldDirty) {\r\n                    set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n                    updateFormState({\r\n                        isDirty: !deepEqual(Object.assign(Object.assign({}, getValues()), { [name]: value }), defaultValuesRef.current),\r\n                        dirtyFields: formStateRef.current.dirtyFields,\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        !shouldUnregister && set(shallowFieldsStateRef.current, name, value);\r\n    }, [updateAndGetDirtyState, setFieldValue, setInternalValues]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    const renderWatchedInputs = (name, found = true) => {\r\n        if (!isEmptyObject(useWatchFieldsRef.current)) {\r\n            for (const key in useWatchFieldsRef.current) {\r\n                if (!name ||\r\n                    !useWatchFieldsRef.current[key].size ||\r\n                    useWatchFieldsRef.current[key].has(name) ||\r\n                    useWatchFieldsRef.current[key].has(getFieldArrayParentName(name))) {\r\n                    useWatchRenderFunctionsRef.current[key]();\r\n                    found = false;\r\n                }\r\n            }\r\n        }\r\n        return found;\r\n    };\r\n    function setValue(name, value, config) {\r\n        setInternalValue(name, value, config);\r\n        isFieldWatched(name) && updateFormState();\r\n        renderWatchedInputs(name);\r\n        (config || {}).shouldValidate && trigger(name);\r\n    }\r\n    handleChangeRef.current = handleChangeRef.current\r\n        ? handleChangeRef.current\r\n        : async ({ type, target }) => {\r\n            let name = target.name;\r\n            const field = fieldsRef.current[name];\r\n            let error;\r\n            let isValid;\r\n            if (field) {\r\n                const isBlurEvent = type === EVENTS.BLUR;\r\n                const shouldSkipValidation = skipValidation(Object.assign({ isBlurEvent,\r\n                    isReValidateOnChange,\r\n                    isReValidateOnBlur, isTouched: !!get(formStateRef.current.touched, name), isSubmitted: formStateRef.current.isSubmitted }, modeRef.current));\r\n                let state = updateAndGetDirtyState(name, false);\r\n                let shouldRender = !isEmptyObject(state) || isFieldWatched(name);\r\n                if (isBlurEvent &&\r\n                    !get(formStateRef.current.touched, name) &&\r\n                    readFormStateRef.current.touched) {\r\n                    set(formStateRef.current.touched, name, true);\r\n                    state = Object.assign(Object.assign({}, state), { touched: formStateRef.current.touched });\r\n                }\r\n                if (shouldSkipValidation) {\r\n                    renderWatchedInputs(name);\r\n                    return ((!isEmptyObject(state) ||\r\n                        (shouldRender && isEmptyObject(state))) &&\r\n                        updateFormState(state));\r\n                }\r\n                if (resolverRef.current) {\r\n                    const { errors } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\r\n                    const previousFormIsValid = formStateRef.current.isValid;\r\n                    error = get(errors, name);\r\n                    if (isCheckBoxInput(target) &&\r\n                        !error &&\r\n                        resolverRef.current) {\r\n                        const parentNodeName = name.substring(0, name.lastIndexOf('.') > name.lastIndexOf('[')\r\n                            ? name.lastIndexOf('.')\r\n                            : name.lastIndexOf('['));\r\n                        const currentError = get(errors, parentNodeName, {});\r\n                        currentError.type &&\r\n                            currentError.message &&\r\n                            (error = currentError);\r\n                        if (parentNodeName &&\r\n                            (currentError ||\r\n                                get(formStateRef.current.errors, parentNodeName))) {\r\n                            name = parentNodeName;\r\n                        }\r\n                    }\r\n                    isValid = isEmptyObject(errors);\r\n                    if (previousFormIsValid !== isValid) {\r\n                        shouldRender = true;\r\n                    }\r\n                }\r\n                else {\r\n                    error = (await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef))[name];\r\n                }\r\n                renderWatchedInputs(name);\r\n                shouldRenderBaseOnError(name, error, shouldRender, state, isValid);\r\n            }\r\n        };\r\n    function setFieldArrayDefaultValues(data) {\r\n        if (!shouldUnregister) {\r\n            let copy = cloneObject(data, isWeb);\r\n            for (const value of fieldArrayNamesRef.current) {\r\n                if (isKey(value) && !copy[value]) {\r\n                    copy = Object.assign(Object.assign({}, copy), { [value]: [] });\r\n                }\r\n            }\r\n            return copy;\r\n        }\r\n        return data;\r\n    }\r\n    function getValues(payload) {\r\n        if (isString(payload)) {\r\n            return getFieldValue(fieldsRef, payload, shallowFieldsStateRef);\r\n        }\r\n        if (Array.isArray(payload)) {\r\n            const data = {};\r\n            for (const name of payload) {\r\n                set(data, name, getFieldValue(fieldsRef, name, shallowFieldsStateRef));\r\n            }\r\n            return data;\r\n        }\r\n        return setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current, isWeb), shouldUnregister));\r\n    }\r\n    const validateResolver = useCallback(async (values = {}) => {\r\n        const { errors } = await resolverRef.current(Object.assign(Object.assign(Object.assign({}, defaultValuesRef.current), getValues()), values), contextRef.current, isValidateAllFieldCriteria);\r\n        const isValid = isEmptyObject(errors);\r\n        formStateRef.current.isValid !== isValid &&\r\n            updateFormState({\r\n                isValid,\r\n            });\r\n    }, [isValidateAllFieldCriteria]);\r\n    const removeFieldEventListener = useCallback((field, forceDelete) => findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, shallowFieldsStateRef, shouldUnregister, forceDelete), [shouldUnregister]);\r\n    const updateWatchedValue = useCallback((name) => {\r\n        if (isWatchAllRef.current) {\r\n            updateFormState();\r\n        }\r\n        else if (watchFieldsRef) {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (watchField.startsWith(name)) {\r\n                    updateFormState();\r\n                    break;\r\n                }\r\n            }\r\n            renderWatchedInputs(name);\r\n        }\r\n    }, []);\r\n    const removeFieldEventListenerAndRef = useCallback((field, forceDelete) => {\r\n        if (field) {\r\n            removeFieldEventListener(field, forceDelete);\r\n            if (shouldUnregister && !compact(field.options || []).length) {\r\n                unset(defaultValuesAtRenderRef.current, field.ref.name);\r\n                unset(validFieldsRef.current, field.ref.name);\r\n                unset(fieldsWithValidationRef.current, field.ref.name);\r\n                unset(formStateRef.current.errors, field.ref.name);\r\n                set(formStateRef.current.dirtyFields, field.ref.name, true);\r\n                updateFormState({\r\n                    errors: formStateRef.current.errors,\r\n                    isDirty: isFormDirty(),\r\n                    dirtyFields: formStateRef.current.dirtyFields,\r\n                });\r\n                readFormStateRef.current.isValid &&\r\n                    resolverRef.current &&\r\n                    validateResolver();\r\n                updateWatchedValue(field.ref.name);\r\n            }\r\n        }\r\n    }, [validateResolver, removeFieldEventListener]);\r\n    function clearErrors(name) {\r\n        name &&\r\n            (Array.isArray(name) ? name : [name]).forEach((inputName) => fieldsRef.current[inputName] && isKey(inputName)\r\n                ? delete formStateRef.current.errors[inputName]\r\n                : unset(formStateRef.current.errors, inputName));\r\n        updateFormState({\r\n            errors: name ? formStateRef.current.errors : {},\r\n        });\r\n    }\r\n    function setError(name, error) {\r\n        const ref = (fieldsRef.current[name] || {}).ref;\r\n        set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        updateFormState({\r\n            isValid: false,\r\n            errors: formStateRef.current.errors,\r\n        });\r\n        error.shouldFocus && ref && ref.focus && ref.focus();\r\n    }\r\n    const watchInternal = useCallback((fieldNames, defaultValue, watchId) => {\r\n        const watchFields = watchId\r\n            ? useWatchFieldsRef.current[watchId]\r\n            : watchFieldsRef.current;\r\n        const combinedDefaultValues = isUndefined(defaultValue)\r\n            ? defaultValuesRef.current\r\n            : defaultValue;\r\n        let fieldValues = getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current, isWeb), shouldUnregister, false, fieldNames);\r\n        if (isString(fieldNames)) {\r\n            if (fieldArrayNamesRef.current.has(fieldNames)) {\r\n                const fieldArrayValue = get(fieldArrayValuesRef.current, fieldNames, []);\r\n                fieldValues =\r\n                    fieldArrayValue.length !==\r\n                        compact(get(fieldValues, fieldNames, [])).length ||\r\n                        !fieldArrayValue.length\r\n                        ? fieldArrayValuesRef.current\r\n                        : fieldValues;\r\n            }\r\n            return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(defaultValue)\r\n                ? get(combinedDefaultValues, fieldNames)\r\n                : defaultValue, true);\r\n        }\r\n        if (Array.isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => (Object.assign(Object.assign({}, previous), { [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues) })), {});\r\n        }\r\n        isWatchAllRef.current = isUndefined(watchId);\r\n        return transformToNestObject((!isEmptyObject(fieldValues) && fieldValues) ||\r\n            combinedDefaultValues);\r\n    }, []);\r\n    function watch(fieldNames, defaultValue) {\r\n        return watchInternal(fieldNames, defaultValue);\r\n    }\r\n    function unregister(name) {\r\n        for (const fieldName of Array.isArray(name) ? name : [name]) {\r\n            removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true);\r\n        }\r\n    }\r\n    function registerFieldRef(ref, validateOptions = {}) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!ref.name) {\r\n                return console.warn(' Field is missing `name` attribute', ref, `https://react-hook-form.com/api#useForm`);\r\n            }\r\n            if (fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) &&\r\n                !RegExp(`^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+].\\\\w+`\r\n                    .replace(/\\[/g, '\\\\[')\r\n                    .replace(/\\]/g, '\\\\]')).test(ref.name)) {\r\n                return console.warn(' `name` prop should be in object shape: name=\"test[index].name\"', ref, 'https://react-hook-form.com/api#useFieldArray');\r\n            }\r\n        }\r\n        const { name, type, value } = ref;\r\n        const fieldRefAndValidationOptions = Object.assign({ ref }, validateOptions);\r\n        const fields = fieldsRef.current;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n        const compareRef = (currentRef) => isWeb && (!isHTMLElement(ref) || currentRef === ref);\r\n        let field = fields[name];\r\n        let isEmptyDefaultValue = true;\r\n        let defaultValue;\r\n        if (field &&\r\n            (isRadioOrCheckbox\r\n                ? Array.isArray(field.options) &&\r\n                    compact(field.options).find((option) => {\r\n                        return value === option.ref.value && compareRef(option.ref);\r\n                    })\r\n                : compareRef(field.ref))) {\r\n            fields[name] = Object.assign(Object.assign({}, field), validateOptions);\r\n            return;\r\n        }\r\n        if (type) {\r\n            field = isRadioOrCheckbox\r\n                ? Object.assign({ options: [\r\n                        ...compact((field && field.options) || []),\r\n                        {\r\n                            ref,\r\n                        },\r\n                    ], ref: { type, name } }, validateOptions) : Object.assign({}, fieldRefAndValidationOptions);\r\n        }\r\n        else {\r\n            field = fieldRefAndValidationOptions;\r\n        }\r\n        fields[name] = field;\r\n        const isEmptyUnmountFields = isUndefined(get(shallowFieldsStateRef.current, name));\r\n        if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\r\n            defaultValue = get(isEmptyUnmountFields\r\n                ? defaultValuesRef.current\r\n                : shallowFieldsStateRef.current, name);\r\n            isEmptyDefaultValue = isUndefined(defaultValue);\r\n            if (!isEmptyDefaultValue && !isFieldArray) {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n        }\r\n        if (!isEmptyObject(validateOptions)) {\r\n            set(fieldsWithValidationRef.current, name, true);\r\n            if (!isOnSubmit && readFormStateRef.current.isValid) {\r\n                validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef).then((error) => {\r\n                    const previousFormIsValid = formStateRef.current.isValid;\r\n                    isEmptyObject(error)\r\n                        ? set(validFieldsRef.current, name, true)\r\n                        : unset(validFieldsRef.current, name);\r\n                    if (previousFormIsValid !== isEmptyObject(error)) {\r\n                        updateFormState();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        if (!defaultValuesAtRenderRef.current[name] &&\r\n            !(isFieldArray && isEmptyDefaultValue)) {\r\n            const fieldValue = getFieldValue(fieldsRef, name, shallowFieldsStateRef);\r\n            set(defaultValuesAtRenderRef.current, name, isEmptyDefaultValue\r\n                ? isObject(fieldValue)\r\n                    ? Object.assign({}, fieldValue) : fieldValue\r\n                : defaultValue);\r\n            !isFieldArray && unset(formStateRef.current.dirtyFields, name);\r\n        }\r\n        if (type) {\r\n            attachEventListeners(isRadioOrCheckbox && field.options\r\n                ? field.options[field.options.length - 1]\r\n                : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);\r\n        }\r\n    }\r\n    function register(refOrValidationOptions, rules) {\r\n        if (!isWindowUndefined) {\r\n            if (isString(refOrValidationOptions)) {\r\n                registerFieldRef({ name: refOrValidationOptions }, rules);\r\n            }\r\n            else if (isObject(refOrValidationOptions) &&\r\n                'name' in refOrValidationOptions) {\r\n                registerFieldRef(refOrValidationOptions, rules);\r\n            }\r\n            else {\r\n                return (ref) => ref && registerFieldRef(ref, refOrValidationOptions);\r\n            }\r\n        }\r\n    }\r\n    const handleSubmit = useCallback((onValid, onInvalid) => async (e) => {\r\n        if (e && e.preventDefault) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors = {};\r\n        let fieldValues = setFieldArrayDefaultValues(getFieldsValues(fieldsRef, cloneObject(shallowFieldsStateRef.current, isWeb), shouldUnregister, true));\r\n        readFormStateRef.current.isSubmitting &&\r\n            updateFormState({\r\n                isSubmitting: true,\r\n            });\r\n        try {\r\n            if (resolverRef.current) {\r\n                const { errors, values } = await resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);\r\n                formStateRef.current.errors = fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                for (const field of Object.values(fieldsRef.current)) {\r\n                    if (field) {\r\n                        const { ref: { name }, } = field;\r\n                        const fieldError = await validateField(fieldsRef, isValidateAllFieldCriteria, field, shallowFieldsStateRef);\r\n                        if (fieldError[name]) {\r\n                            set(fieldErrors, name, fieldError[name]);\r\n                            unset(validFieldsRef.current, name);\r\n                        }\r\n                        else if (get(fieldsWithValidationRef.current, name)) {\r\n                            unset(formStateRef.current.errors, name);\r\n                            set(validFieldsRef.current, name, true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isEmptyObject(fieldErrors) &&\r\n                Object.keys(formStateRef.current.errors).every((name) => name in fieldsRef.current)) {\r\n                updateFormState({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                formStateRef.current.errors = Object.assign(Object.assign({}, formStateRef.current.errors), fieldErrors);\r\n                onInvalid && (await onInvalid(formStateRef.current.errors, e));\r\n                shouldFocusError &&\r\n                    focusOnErrorField(fieldsRef.current, formStateRef.current.errors);\r\n            }\r\n        }\r\n        finally {\r\n            formStateRef.current.isSubmitting = false;\r\n            updateFormState({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(formStateRef.current.errors),\r\n                errors: formStateRef.current.errors,\r\n                submitCount: formStateRef.current.submitCount + 1,\r\n            });\r\n        }\r\n    }, [shouldFocusError, isValidateAllFieldCriteria]);\r\n    const resetRefs = ({ errors, isDirty, isSubmitted, touched, isValid, submitCount, dirtyFields, }) => {\r\n        if (!isValid) {\r\n            validFieldsRef.current = {};\r\n            fieldsWithValidationRef.current = {};\r\n        }\r\n        defaultValuesAtRenderRef.current = {};\r\n        fieldArrayDefaultValuesRef.current = {};\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n        updateFormState({\r\n            submitCount: submitCount ? formStateRef.current.submitCount : 0,\r\n            isDirty: isDirty ? formStateRef.current.isDirty : false,\r\n            isSubmitted: isSubmitted ? formStateRef.current.isSubmitted : false,\r\n            isValid: isValid ? formStateRef.current.isValid : false,\r\n            dirtyFields: dirtyFields ? formStateRef.current.dirtyFields : {},\r\n            touched: touched ? formStateRef.current.touched : {},\r\n            errors: errors ? formStateRef.current.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n    };\r\n    const reset = (values, omitResetState = {}) => {\r\n        if (isWeb) {\r\n            for (const field of Object.values(fieldsRef.current)) {\r\n                if (field) {\r\n                    const { ref, options } = field;\r\n                    const inputRef = isRadioOrCheckboxFunction(ref) && Array.isArray(options)\r\n                        ? options[0].ref\r\n                        : ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        fieldsRef.current = {};\r\n        defaultValuesRef.current = cloneObject(values || defaultValuesRef.current, isWeb);\r\n        values && renderWatchedInputs('');\r\n        Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray());\r\n        shallowFieldsStateRef.current = shouldUnregister\r\n            ? {}\r\n            : cloneObject(values, isWeb) || {};\r\n        resetRefs(omitResetState);\r\n    };\r\n    useEffect(() => {\r\n        resolver && readFormStateRef.current.isValid && validateResolver();\r\n        observerRef.current =\r\n            observerRef.current || !isWeb\r\n                ? observerRef.current\r\n                : onDomRemove(fieldsRef, removeFieldEventListenerAndRef);\r\n    }, [removeFieldEventListenerAndRef, defaultValuesRef.current]);\r\n    useEffect(() => () => {\r\n        isUnMount.current = true;\r\n        observerRef.current && observerRef.current.disconnect();\r\n        Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));\r\n    }, []);\r\n    if (!resolver && readFormStateRef.current.isValid) {\r\n        formState.isValid =\r\n            deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\r\n                isEmptyObject(formStateRef.current.errors);\r\n    }\r\n    const commonProps = {\r\n        trigger,\r\n        setValue: useCallback(setValue, [setInternalValue, trigger]),\r\n        getValues: useCallback(getValues, []),\r\n        register: useCallback(register, [defaultValuesRef.current]),\r\n        unregister: useCallback(unregister, []),\r\n    };\r\n    const control = useMemo(() => (Object.assign({ isFormDirty,\r\n        updateWatchedValue,\r\n        shouldUnregister,\r\n        updateFormState,\r\n        removeFieldEventListener,\r\n        watchInternal, mode: modeRef.current, reValidateMode: {\r\n            isReValidateOnBlur,\r\n            isReValidateOnChange,\r\n        }, validateResolver: resolver ? validateResolver : undefined, fieldsRef,\r\n        resetFieldArrayFunctionRef,\r\n        useWatchFieldsRef,\r\n        useWatchRenderFunctionsRef,\r\n        fieldArrayDefaultValuesRef,\r\n        validFieldsRef,\r\n        fieldsWithValidationRef,\r\n        fieldArrayNamesRef,\r\n        readFormStateRef,\r\n        formStateRef,\r\n        defaultValuesRef,\r\n        shallowFieldsStateRef,\r\n        fieldArrayValuesRef }, commonProps)), [\r\n        defaultValuesRef.current,\r\n        updateWatchedValue,\r\n        shouldUnregister,\r\n        removeFieldEventListener,\r\n        watchInternal,\r\n    ]);\r\n    return Object.assign({ watch,\r\n        control, formState: isProxyEnabled\r\n            ? new Proxy(formState, {\r\n                get: (obj, prop) => {\r\n                    if (process.env.NODE_ENV !== 'production') {\r\n                        if (prop === 'isValid' && isOnSubmit) {\r\n                            console.warn(' `formState.isValid` is applicable with `onTouched`, `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState');\r\n                        }\r\n                    }\r\n                    if (prop in obj) {\r\n                        readFormStateRef.current[prop] = true;\r\n                        return obj[prop];\r\n                    }\r\n                    return undefined;\r\n                },\r\n            })\r\n            : formState, handleSubmit, reset: useCallback(reset, []), clearErrors: useCallback(clearErrors, []), setError: useCallback(setError, []), errors: formState.errors }, commonProps);\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst FormContext = createContext(null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => useContext(FormContext);\r\nconst FormProvider = (_a) => {\r\n    var { children } = _a, props = __rest(_a, [\"children\"]);\r\n    return (createElement(FormContext.Provider, { value: Object.assign({}, props) }, children));\r\n};\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nconst removeAt = (data, index) => [\r\n    ...data.slice(0, index),\r\n    ...data.slice(index + 1),\r\n];\r\nfunction removeAtIndexes(data, index) {\r\n    let k = -1;\r\n    while (++k < data.length) {\r\n        if (index.indexOf(k) >= 0) {\r\n            delete data[k];\r\n        }\r\n    }\r\n    return compact(data);\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : Array.isArray(index)\r\n        ? removeAtIndexes(data, index)\r\n        : removeAt(data, index);\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    const temp = [data[indexB], data[indexA]];\r\n    data[indexA] = temp[0];\r\n    data[indexB] = temp[1];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(Array.isArray(value) ? value : [value || undefined]), ...data];\r\n}\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(Array.isArray(value) ? value : [value || undefined]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction mapValueToBoolean(value) {\r\n    if (isObject(value)) {\r\n        const object = {};\r\n        for (const key in value) {\r\n            object[key] = true;\r\n        }\r\n        return [object];\r\n    }\r\n    return [true];\r\n}\r\nvar fillBooleanArray = (value) => (Array.isArray(value) ? value : [value])\r\n    .map(mapValueToBoolean)\r\n    .flat();\n\nconst mapIds = (values = [], keyName) => {\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        for (const value of values) {\r\n            if (!!value && keyName in value) {\r\n                console.warn(` useFieldArray fieldValues contain the keyName \\`${keyName}\\` which is reserved for use by useFieldArray. https://react-hook-form.com/api#useFieldArray`);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return values.map((value) => (Object.assign({ [keyName]: generateId() }, value)));\r\n};\r\nconst useFieldArray = ({ control, name, keyName = 'id', }) => {\r\n    const methods = useFormContext();\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!control && !methods) {\r\n            throw new Error(' useFieldArray is missing `control` prop. https://react-hook-form.com/api#useFieldArray');\r\n        }\r\n    }\r\n    const focusIndexRef = useRef(-1);\r\n    const { isFormDirty, updateWatchedValue, resetFieldArrayFunctionRef, fieldArrayNamesRef, fieldsRef, defaultValuesRef, removeFieldEventListener, formStateRef, shallowFieldsStateRef, updateFormState, readFormStateRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValuesRef, validateResolver, getValues, shouldUnregister, fieldArrayValuesRef, } = control || methods.control;\r\n    const fieldArrayParentName = getFieldArrayParentName(name);\r\n    const memoizedDefaultValues = useRef([\r\n        ...(get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)\r\n            ? get(fieldArrayDefaultValuesRef.current, name, [])\r\n            : get(shouldUnregister\r\n                ? defaultValuesRef.current\r\n                : shallowFieldsStateRef.current, name, [])),\r\n    ]);\r\n    const [fields, setFields] = useState(mapIds(memoizedDefaultValues.current, keyName));\r\n    set(fieldArrayValuesRef.current, name, fields);\r\n    const getFieldArrayValue = useCallback(() => get(fieldArrayValuesRef.current, name, []), []);\r\n    const getCurrentFieldsValues = () => get(getValues(), name, getFieldArrayValue()).map((item, index) => (Object.assign(Object.assign({}, getFieldArrayValue()[index]), item)));\r\n    fieldArrayNamesRef.current.add(name);\r\n    if (fieldArrayParentName &&\r\n        !get(fieldArrayDefaultValuesRef.current, fieldArrayParentName)) {\r\n        set(fieldArrayDefaultValuesRef.current, fieldArrayParentName, get(defaultValuesRef.current, fieldArrayParentName));\r\n    }\r\n    const setFieldAndValidState = (fieldsValues) => {\r\n        setFields(fieldsValues);\r\n        set(fieldArrayValuesRef.current, name, fieldsValues);\r\n        if (readFormStateRef.current.isValid && validateResolver) {\r\n            const values = getValues();\r\n            set(values, name, fieldsValues);\r\n            validateResolver(values);\r\n        }\r\n    };\r\n    const resetFields = () => {\r\n        for (const key in fieldsRef.current) {\r\n            isMatchFieldArrayName(key, name) &&\r\n                removeFieldEventListener(fieldsRef.current[key], true);\r\n        }\r\n    };\r\n    const cleanup = (ref) => !compact(get(ref, name, [])).length && unset(ref, name);\r\n    const updateDirtyFieldsWithDefaultValues = (updatedFieldArrayValues) => {\r\n        const defaultFieldArrayValues = get(defaultValuesRef.current, name, []);\r\n        const updateDirtyFieldsBaseOnDefaultValues = (base, target) => {\r\n            for (const key in base) {\r\n                for (const innerKey in base[key]) {\r\n                    if (innerKey !== keyName &&\r\n                        (!target[key] ||\r\n                            !base[key] ||\r\n                            base[key][innerKey] !== target[key][innerKey])) {\r\n                        set(formStateRef.current.dirtyFields, `${name}[${key}]`, Object.assign(Object.assign({}, get(formStateRef.current.dirtyFields, `${name}[${key}]`, {})), { [innerKey]: true }));\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        if (updatedFieldArrayValues) {\r\n            updateDirtyFieldsBaseOnDefaultValues(defaultFieldArrayValues, updatedFieldArrayValues);\r\n            updateDirtyFieldsBaseOnDefaultValues(updatedFieldArrayValues, defaultFieldArrayValues);\r\n        }\r\n    };\r\n    const batchStateUpdate = (method, args, updatedFieldValues, updatedFormValues = [], shouldSet = true, shouldUpdateValid = false) => {\r\n        if (get(shallowFieldsStateRef.current, name)) {\r\n            const output = method(get(shallowFieldsStateRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(shallowFieldsStateRef.current, name, output);\r\n        }\r\n        if (get(fieldArrayDefaultValuesRef.current, name)) {\r\n            const output = method(get(fieldArrayDefaultValuesRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(fieldArrayDefaultValuesRef.current, name, output);\r\n            cleanup(fieldArrayDefaultValuesRef.current);\r\n        }\r\n        if (Array.isArray(get(formStateRef.current.errors, name))) {\r\n            const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.errors, name, output);\r\n            cleanup(formStateRef.current.errors);\r\n        }\r\n        if (readFormStateRef.current.touched &&\r\n            get(formStateRef.current.touched, name)) {\r\n            const output = method(get(formStateRef.current.touched, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.touched, name, output);\r\n            cleanup(formStateRef.current.touched);\r\n        }\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            const output = method(get(formStateRef.current.dirtyFields, name, []), args.argC, args.argD);\r\n            shouldSet && set(formStateRef.current.dirtyFields, name, output);\r\n            updateDirtyFieldsWithDefaultValues(updatedFieldValues);\r\n            cleanup(formStateRef.current.dirtyFields);\r\n        }\r\n        if (shouldUpdateValid &&\r\n            readFormStateRef.current.isValid &&\r\n            !validateResolver) {\r\n            set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\r\n            cleanup(validFieldsRef.current);\r\n            set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\r\n            cleanup(fieldsWithValidationRef.current);\r\n        }\r\n        updateFormState({\r\n            errors: formStateRef.current.errors,\r\n            dirtyFields: formStateRef.current.dirtyFields,\r\n            isDirty: isFormDirty(name, updatedFormValues.map((_a = {}) => {\r\n                var _b = keyName, omitted = _a[_b], rest = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\r\n                return rest;\r\n            })),\r\n            touched: formStateRef.current.touched,\r\n        });\r\n    };\r\n    const append = (value, shouldFocus = true) => {\r\n        const updateFormValues = [\r\n            ...getFieldArrayValue(),\r\n            ...mapIds(Array.isArray(value) ? value : [value], keyName),\r\n        ];\r\n        setFieldAndValidState(updateFormValues);\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            updateDirtyFieldsWithDefaultValues(updateFormValues);\r\n            updateFormState({\r\n                isDirty: true,\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n            });\r\n        }\r\n        !shouldUnregister &&\r\n            set(shallowFieldsStateRef.current, name, [\r\n                ...(get(shallowFieldsStateRef.current, name) || []),\r\n                value,\r\n            ]);\r\n        focusIndexRef.current = shouldFocus ? fields.length : -1;\r\n    };\r\n    const prepend$1 = (value, shouldFocus = true) => {\r\n        const emptyArray = fillEmptyArray(value);\r\n        const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), mapIds(Array.isArray(value) ? value : [value], keyName));\r\n        setFieldAndValidState(updatedFieldArrayValues);\r\n        resetFields();\r\n        batchStateUpdate(prepend, {\r\n            argA: emptyArray,\r\n            argC: fillBooleanArray(value),\r\n        }, updatedFieldArrayValues);\r\n        focusIndexRef.current = shouldFocus ? 0 : -1;\r\n    };\r\n    const remove = (index) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        const updatedFieldValues = removeArrayAt(fieldValues, index);\r\n        setFieldAndValidState(updatedFieldValues);\r\n        resetFields();\r\n        batchStateUpdate(removeArrayAt, {\r\n            argA: index,\r\n            argC: index,\r\n        }, updatedFieldValues, removeArrayAt(fieldValues, index), true, true);\r\n    };\r\n    const insert$1 = (index, value, shouldFocus = true) => {\r\n        const emptyArray = fillEmptyArray(value);\r\n        const fieldValues = getCurrentFieldsValues();\r\n        const updatedFieldArrayValues = insert(fieldValues, index, mapIds(Array.isArray(value) ? value : [value], keyName));\r\n        setFieldAndValidState(updatedFieldArrayValues);\r\n        resetFields();\r\n        batchStateUpdate(insert, {\r\n            argA: index,\r\n            argB: emptyArray,\r\n            argC: index,\r\n            argD: fillBooleanArray(value),\r\n        }, updatedFieldArrayValues, insert(fieldValues, index));\r\n        focusIndexRef.current = shouldFocus ? index : -1;\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        resetFields();\r\n        setFieldAndValidState([...fieldValues]);\r\n        batchStateUpdate(swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n            argC: indexA,\r\n            argD: indexB,\r\n        }, undefined, fieldValues, false);\r\n    };\r\n    const move = (from, to) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        moveArrayAt(fieldValues, from, to);\r\n        resetFields();\r\n        setFieldAndValidState([...fieldValues]);\r\n        batchStateUpdate(moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n            argC: from,\r\n            argD: to,\r\n        }, undefined, fieldValues, false);\r\n    };\r\n    useEffect(() => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (!name) {\r\n                console.warn(' useFieldArray is missing `name` attribute. https://react-hook-form.com/api#useFieldArray');\r\n            }\r\n        }\r\n        const defaultValues = get(fieldArrayDefaultValuesRef.current, name);\r\n        if (defaultValues && fields.length < defaultValues.length) {\r\n            defaultValues.pop();\r\n            set(fieldArrayDefaultValuesRef.current, name, defaultValues);\r\n        }\r\n        updateWatchedValue(name);\r\n        if (focusIndexRef.current > -1) {\r\n            for (const key in fieldsRef.current) {\r\n                const field = fieldsRef.current[key];\r\n                if (key.startsWith(`${name}[${focusIndexRef.current}]`) &&\r\n                    field.ref.focus) {\r\n                    field.ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        focusIndexRef.current = -1;\r\n    }, [fields, name]);\r\n    useEffect(() => {\r\n        const resetFunctions = resetFieldArrayFunctionRef.current;\r\n        const fieldArrayNames = fieldArrayNamesRef.current;\r\n        if (!getFieldArrayParentName(name)) {\r\n            resetFunctions[name] = (data) => {\r\n                resetFields();\r\n                !data && unset(fieldArrayDefaultValuesRef.current, name);\r\n                unset(shallowFieldsStateRef.current, name);\r\n                memoizedDefaultValues.current = get(data || defaultValuesRef.current, name);\r\n                setFields(mapIds(memoizedDefaultValues.current, keyName));\r\n            };\r\n        }\r\n        return () => {\r\n            resetFields();\r\n            delete resetFunctions[name];\r\n            unset(fieldArrayValuesRef, name);\r\n            fieldArrayNames.delete(name);\r\n        };\r\n    }, []);\r\n    return {\r\n        swap: useCallback(swap, [name]),\r\n        move: useCallback(move, [name]),\r\n        prepend: useCallback(prepend$1, [name]),\r\n        append: useCallback(append, [name, fields]),\r\n        remove: useCallback(remove, [name]),\r\n        insert: useCallback(insert$1, [name]),\r\n        fields,\r\n    };\r\n};\n\nfunction useWatch({ control, name, defaultValue, }) {\r\n    const methods = useFormContext();\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!control && !methods) {\r\n            throw new Error(' useWatch is missing `control` prop. https://react-hook-form.com/api#useWatch');\r\n        }\r\n    }\r\n    const { useWatchFieldsRef, useWatchRenderFunctionsRef, watchInternal, defaultValuesRef, } = control || methods.control;\r\n    const updateValue = useState()[1];\r\n    const idRef = useRef();\r\n    const defaultValueRef = useRef(defaultValue);\r\n    useEffect(() => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (name === '') {\r\n                console.warn(' useWatch is missing `name` attribute. https://react-hook-form.com/api#useWatch');\r\n            }\r\n        }\r\n        const id = (idRef.current = generateId());\r\n        const watchFieldsHookRender = useWatchRenderFunctionsRef.current;\r\n        const watchFieldsHook = useWatchFieldsRef.current;\r\n        watchFieldsHook[id] = new Set();\r\n        watchFieldsHookRender[id] = () => updateValue({});\r\n        watchInternal(name, defaultValueRef.current, id);\r\n        return () => {\r\n            delete watchFieldsHook[id];\r\n            delete watchFieldsHookRender[id];\r\n        };\r\n    }, [\r\n        name,\r\n        useWatchRenderFunctionsRef,\r\n        useWatchFieldsRef,\r\n        watchInternal,\r\n        defaultValueRef,\r\n    ]);\r\n    return idRef.current\r\n        ? watchInternal(name, defaultValueRef.current, idRef.current)\r\n        : isUndefined(defaultValue)\r\n            ? isString(name)\r\n                ? get(defaultValuesRef.current, name)\r\n                : Array.isArray(name)\r\n                    ? name.reduce((previous, inputName) => (Object.assign(Object.assign({}, previous), { [inputName]: get(defaultValuesRef.current, inputName) })), {})\r\n                    : defaultValuesRef.current\r\n            : defaultValue;\r\n}\n\nvar getInputValue = (event) => isPrimitive(event) ||\r\n    !isObject(event.target) ||\r\n    (isObject(event.target) && !event.type)\r\n    ? event\r\n    : isUndefined(event.target.value)\r\n        ? event.target.checked\r\n        : event.target.value;\n\nconst Controller = (_a) => {\r\n    var { name, rules, as, render, defaultValue, control, onFocus } = _a, rest = __rest(_a, [\"name\", \"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\r\n    const methods = useFormContext();\r\n    if (process.env.NODE_ENV !== 'production') {\r\n        if (!control && !methods) {\r\n            throw new Error(' Controller is missing `control` prop. https://react-hook-form.com/api#Controller');\r\n        }\r\n    }\r\n    const { defaultValuesRef, setValue, register, unregister, trigger, mode, reValidateMode: { isReValidateOnBlur, isReValidateOnChange }, formStateRef: { current: { isSubmitted, touched }, }, updateFormState, readFormStateRef, fieldsRef, fieldArrayNamesRef, shallowFieldsStateRef, } = control || methods.control;\r\n    const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    const getInitialValue = () => !isUndefined(get(shallowFieldsStateRef.current, name)) && isNotFieldArray\r\n        ? get(shallowFieldsStateRef.current, name)\r\n        : isUndefined(defaultValue)\r\n            ? get(defaultValuesRef.current, name)\r\n            : defaultValue;\r\n    const [value, setInputStateValue] = useState(getInitialValue());\r\n    const valueRef = useRef(value);\r\n    const ref = useRef({\r\n        focus: () => null,\r\n    });\r\n    const onFocusRef = useRef(onFocus ||\r\n        (() => {\r\n            if (isFunction(ref.current.focus)) {\r\n                ref.current.focus();\r\n            }\r\n            else {\r\n                if (process.env.NODE_ENV !== 'production') {\r\n                    console.warn(` 'ref' from Controller render prop must be attached to a React component or a DOM Element whose ref provides a 'focus()' method`);\r\n                }\r\n            }\r\n        }));\r\n    const shouldValidate = useCallback((isBlurEvent) => !skipValidation(Object.assign({ isBlurEvent,\r\n        isReValidateOnBlur,\r\n        isReValidateOnChange,\r\n        isSubmitted, isTouched: !!get(touched, name) }, mode)), [\r\n        isReValidateOnBlur,\r\n        isReValidateOnChange,\r\n        isSubmitted,\r\n        touched,\r\n        name,\r\n        mode,\r\n    ]);\r\n    const commonTask = useCallback(([event]) => {\r\n        const data = getInputValue(event);\r\n        setInputStateValue(data);\r\n        valueRef.current = data;\r\n        return data;\r\n    }, []);\r\n    const registerField = useCallback((shouldUpdateValue) => {\r\n        if (process.env.NODE_ENV !== 'production' && !name) {\r\n            return console.warn(' Field is missing `name` prop. https://react-hook-form.com/api#Controller');\r\n        }\r\n        if (fieldsRef.current[name]) {\r\n            fieldsRef.current[name] = Object.assign({ ref: fieldsRef.current[name].ref }, rules);\r\n        }\r\n        else {\r\n            register(Object.defineProperty({\r\n                name,\r\n                focus: onFocusRef.current,\r\n            }, 'value', {\r\n                set(data) {\r\n                    setInputStateValue(data);\r\n                    valueRef.current = data;\r\n                },\r\n                get() {\r\n                    return valueRef.current;\r\n                },\r\n            }), rules);\r\n            shouldUpdateValue = !get(defaultValuesRef.current, name);\r\n        }\r\n        shouldUpdateValue &&\r\n            isNotFieldArray &&\r\n            setInputStateValue(getInitialValue());\r\n    }, [rules, name, register]);\r\n    useEffect(() => () => unregister(name), [unregister, name]);\r\n    useEffect(() => {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n            if (isUndefined(value)) {\r\n                console.warn(` ${name} is missing in the 'defaultValue' prop of either its Controller (https://react-hook-form.com/api#Controller) or useForm (https://react-hook-form.com/api#useForm)`);\r\n            }\r\n            if ((!as && !render) || (as && render)) {\r\n                console.warn(` ${name} Controller should use either the 'as' or 'render' prop, not both. https://react-hook-form.com/api#Controller`);\r\n            }\r\n            if (!isNotFieldArray && isUndefined(defaultValue)) {\r\n                console.warn(' Controller is missing `defaultValue` prop when using `useFieldArray`. https://react-hook-form.com/api#Controller');\r\n            }\r\n        }\r\n        registerField();\r\n    }, [registerField]);\r\n    useEffect(() => {\r\n        !fieldsRef.current[name] && registerField(true);\r\n    });\r\n    const onBlur = useCallback(() => {\r\n        if (readFormStateRef.current.touched && !get(touched, name)) {\r\n            set(touched, name, true);\r\n            updateFormState({\r\n                touched,\r\n            });\r\n        }\r\n        shouldValidate(true) && trigger(name);\r\n    }, [\r\n        name,\r\n        touched,\r\n        updateFormState,\r\n        shouldValidate,\r\n        trigger,\r\n        readFormStateRef,\r\n    ]);\r\n    const onChange = useCallback((...event) => setValue(name, commonTask(event), {\r\n        shouldValidate: shouldValidate(),\r\n        shouldDirty: true,\r\n    }), [setValue, name, shouldValidate]);\r\n    const commonProps = {\r\n        onChange,\r\n        onBlur,\r\n        name,\r\n        value,\r\n        ref,\r\n    };\r\n    const props = Object.assign(Object.assign({}, rest), commonProps);\r\n    return as\r\n        ? isValidElement(as)\r\n            ? cloneElement(as, props)\r\n            : createElement(as, props)\r\n        : render\r\n            ? render(commonProps)\r\n            : null;\r\n};\n\nexport { Controller, FormProvider, appendErrors, get, transformToNestObject, useFieldArray, useForm, useFormContext, useWatch };\n//# sourceMappingURL=index.esm.js.map\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import arrayWithoutHoles from \"./arrayWithoutHoles\";\nimport iterableToArray from \"./iterableToArray\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nimport nonIterableSpread from \"./nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","import arrayLikeToArray from \"./arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}"],"sourceRoot":""}